#include <sys/types.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/time.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <cutils/sockets.h>
#include <ctype.h>
#include <pthread.h>
#include <errno.h>
#include <cutils/properties.h>
#include <cutils/log.h>
#include "wifi_mac_generate.h"

#define MAC_WIFI_ADDR_TEMP  "/data/vendor/wifi/wifimac_tmp.txt"
#define PRODUCTINFO_MAC_WIFI_ADDR "/mnt/vendor/wifimac.txt"
#define MAC_LEN 6
bool is_zero_ether_addr(const unsigned char *mac)
{
	return !(mac[0] | mac[1] | mac[2] | mac[3] | mac[4] | mac[5]);
}

long get_seed(void)
{
	struct timeval t;
	unsigned long seed = 0;

	gettimeofday(&t, NULL);
	seed = 1000000 * t.tv_sec + t.tv_usec;
	WMGENER_LOG("generate seed: %lu", seed);
	return seed;
}

/* This function is for internal test only */
void get_random_mac(unsigned char *mac)
{
	int i;

	WMGENER_LOG("generate random mac");
	memset(mac, 0, MAC_LEN);

	srand(get_seed()); /* machine run time in us */
	for (i = 0; i < MAC_LEN; i++)
		mac[i] = rand() & 0xFF;
	/*
	mac[0] &= 0xFE;  clear multicast bit
	mac[0] &= 0xFD;  clear local assignment bit, p2p MAC will be auto
	generated by set this bit to 1
	Set Spreadtrum 24bit OUI
	*/
	mac[0] = 0x40;
	mac[1] = 0x45;
	mac[2] = 0xDA;
}

void force_replace_file(const char *dst_file_path, const char *src_file_path)
{
	FILE *f_src, *f_dst;
	char buf[100];

	f_src = fopen(src_file_path, "r");
	if (f_src == NULL)
		return;
	fgets(buf, sizeof(buf), f_src);
	fclose(f_src);

	f_dst = fopen(dst_file_path, "w");
	if (f_dst == NULL)
		return;
	fputs(buf, f_dst);
	fclose(f_dst);

	sprintf(buf, "chmod 660 %s", dst_file_path);
	system(buf);
	WMGENER_LOG("force_replace_config_file: %s", buf);
}

void read_mac_from_file(const char *file_path, unsigned char *mac)
{
	FILE *f;
	unsigned char mac_src[MAC_LEN];
	char buf[20];

	f = fopen(file_path, "r");
	if (f == NULL)
		return;
	if (fscanf(f, "%02x:%02x:%02x:%02x:%02x:%02x", &mac_src[0], &mac_src[1],
		&mac_src[2], &mac_src[3], &mac_src[4], &mac_src[5]) == 6) {
		memcpy(mac, mac_src, MAC_LEN);
		sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", mac_src[0], mac_src[1],
		mac_src[2], mac_src[3], mac_src[4], mac_src[5]);
		WMGENER_LOG("mac from configuration file: %s", buf);
	} else {
		memset(mac, 0, MAC_LEN);
	}
	fclose(f);
}
void write_mac_to_file(const char *file_path, const unsigned char *mac)
{
	FILE *f;
	unsigned char mac_src[MAC_LEN];
	char buf[100];

	f = fopen(file_path, "w");
	/*if (f == NULL) return;*/
	if (f == NULL) {
		WMGENER_LOG("open %s fail", file_path);
		return;
	}
	sprintf(buf, "%02x:%02x:%02x:%02x:%02x:%02x", mac[0], mac[1], mac[2],
		mac[3], mac[4], mac[5]);
	fputs(buf, f);
	WMGENER_LOG("write mac to %s success: %s", file_path, buf);
	fsync(fileno(f));
	fclose(f);
	system(buf);
}

bool is_file_exists(const char *file_path) { return access(file_path, 0) == 0; }


int main(void)
{
	int fd;
	int ret = 0;
	unsigned char mac[MAC_LEN];

	WMGENER_LOG("start wifi_mac_generator,%s", __func__);
	if (is_file_exists(PRODUCTINFO_MAC_WIFI_ADDR))
		return 0;
	WMGENER_LOG("%s is not exist!\n", PRODUCTINFO_MAC_WIFI_ADDR);

	if (is_file_exists(MAC_WIFI_ADDR_TEMP))
		return 0;
	WMGENER_LOG("%s is not exist!\n", MAC_WIFI_ADDR_TEMP);

	get_random_mac(mac);
	fd = open(MAC_WIFI_ADDR_TEMP, O_CREAT | O_RDWR | O_TRUNC, 0666);
	WMGENER_LOG("%s: mac=%s, fd[%s]=%d, errno=%d, errstr=%s\n", __func__,
		mac, MAC_WIFI_ADDR_TEMP, fd, errno, strerror(errno));
	if (fd >= 0) {
		WMGENER_LOG("%s create success\n", MAC_WIFI_ADDR_TEMP);
		close(fd);
		write_mac_to_file(MAC_WIFI_ADDR_TEMP, mac);
	} else {
		WMGENER_LOG("%s create fail:fd=%s\n", MAC_WIFI_ADDR_TEMP, fd);
	}

	return 0;
}
